# IndexTTS 应用开发示例

## 完整应用示例

### 1. 有声读物制作工具

```python
import os
import json
import re
from typing import List, Dict
from indextts.infer import IndexTTS
from pathlib import Path

class AudioBookGenerator:
    """有声读物生成器"""
    
    def __init__(self, model_dir="checkpoints", voices_dir="voices"):
        self.tts = IndexTTS(model_dir=model_dir)
        self.voices_dir = voices_dir
        self.voices = self._load_voices()
        
    def _load_voices(self) -> Dict[str, str]:
        """加载可用的声音库"""
        voices = {}
        if os.path.exists(self.voices_dir):
            for file in os.listdir(self.voices_dir):
                if file.endswith('.wav'):
                    name = file.replace('.wav', '')
                    voices[name] = os.path.join(self.voices_dir, file)
        return voices
    
    def preprocess_text(self, text: str) -> List[Dict]:
        """预处理文本，分章节和段落"""
        # 按章节分割
        chapters = re.split(r'第[一二三四五六七八九十\d]+章|Chapter\s+\d+', text)
        
        processed = []
        for i, chapter in enumerate(chapters[1:], 1):  # 跳过第一个空章节
            # 按段落分割
            paragraphs = [p.strip() for p in chapter.split('\n\n') if p.strip()]
            
            chapter_data = {
                'chapter_num': i,
                'paragraphs': paragraphs,
                'total_chars': sum(len(p) for p in paragraphs)
            }
            processed.append(chapter_data)
            
        return processed
    
    def generate_audiobook(
        self, 
        text_file: str, 
        output_dir: str,
        voice_name: str = "default",
        pause_between_paragraphs: float = 1.0
    ):
        """生成完整有声读物"""
        
        # 读取文本
        with open(text_file, 'r', encoding='utf-8') as f:
            text = f.read()
            
        # 预处理
        chapters = self.preprocess_text(text)
        
        # 检查声音文件
        if voice_name not in self.voices:
            raise ValueError(f"声音 '{voice_name}' 不存在，可用声音: {list(self.voices.keys())}")
            
        voice_path = self.voices[voice_name]
        
        # 创建输出目录
        os.makedirs(output_dir, exist_ok=True)
        
        # 生成元数据
        metadata = {
            'title': Path(text_file).stem,
            'voice': voice_name,
            'total_chapters': len(chapters),
            'generated_at': str(datetime.now()),
            'chapters': []
        }
        
        print(f"开始生成有声读物，共 {len(chapters)} 章节")
        
        for chapter in chapters:
            chapter_num = chapter['chapter_num']
            chapter_file = os.path.join(output_dir, f"chapter_{chapter_num:02d}.wav")
            
            print(f"生成第 {chapter_num} 章...")
            
            # 合并章节所有段落
            chapter_text = f"\n\n".join(chapter['paragraphs'])
            
            try:
                # 生成音频
                self.tts.infer_fast(
                    audio_prompt=voice_path,
                    text=chapter_text,
                    output_path=chapter_file,
                    max_text_tokens_per_sentence=100,
                    sentences_bucket_max_size=4
                )
                
                # 添加到元数据
                metadata['chapters'].append({
                    'chapter': chapter_num,
                    'file': f"chapter_{chapter_num:02d}.wav",
                    'duration': self._get_audio_duration(chapter_file),
                    'char_count': chapter['total_chars']
                })
                
                print(f"✓ 第 {chapter_num} 章完成")
                
            except Exception as e:
                print(f"✗ 第 {chapter_num} 章生成失败: {e}")
                
        # 保存元数据
        with open(os.path.join(output_dir, 'metadata.json'), 'w', encoding='utf-8') as f:
            json.dump(metadata, f, ensure_ascii=False, indent=2)
            
        print(f"有声读物生成完成，输出目录: {output_dir}")
        return metadata
    
    def _get_audio_duration(self, audio_path: str) -> float:
        """获取音频时长"""
        import librosa
        try:
            duration = librosa.get_duration(filename=audio_path)
            return round(duration, 2)
        except:
            return 0.0

# 使用示例
if __name__ == "__main__":
    generator = AudioBookGenerator()
    
    # 生成有声读物
    metadata = generator.generate_audiobook(
        text_file="novel.txt",
        output_dir="audiobook_output",
        voice_name="narrator"
    )
```

### 2. 多语言语音助手

```python
import speech_recognition as sr
import threading
import queue
from indextts.infer import IndexTTS

class VoiceAssistant:
    """多语言语音助手"""
    
    def __init__(self, models_config: Dict[str, Dict]):
        """
        models_config: {
            "zh": {"model_dir": "checkpoints_zh", "voice": "chinese_voice.wav"},
            "en": {"model_dir": "checkpoints_en", "voice": "english_voice.wav"}
        }
        """
        self.models = {}
        self.current_language = "zh"
        
        # 初始化各语言模型
        for lang, config in models_config.items():
            self.models[lang] = {
                'tts': IndexTTS(model_dir=config['model_dir']),
                'voice': config['voice']
            }
        
        # 语音识别
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()
        
        # 任务队列
        self.speech_queue = queue.Queue()
        self.is_listening = False
        
    def detect_language(self, text: str) -> str:
        """简单语言检测"""
        import re
        chinese_chars = len(re.findall(r'[\u4e00-\u9fff]', text))
        total_chars = len(text.replace(' ', ''))
        
        if chinese_chars / max(total_chars, 1) > 0.3:
            return "zh"
        else:
            return "en"
    
    def speak(self, text: str, language: str = None):
        """语音合成并播放"""
        if not text.strip():
            return
            
        if language is None:
            language = self.detect_language(text)
            
        if language not in self.models:
            language = self.current_language
            
        print(f"[{language.upper()}] 合成语音: {text[:50]}...")
        
        try:
            # 生成临时音频文件
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                output_path = temp_file.name
                
            # 合成语音
            model_info = self.models[language]
            model_info['tts'].infer(
                audio_prompt=model_info['voice'],
                text=text,
                output_path=output_path,
                temperature=0.8,
                top_p=0.9
            )
            
            # 播放音频
            self._play_audio(output_path)
            
            # 清理临时文件
            os.unlink(output_path)
            
        except Exception as e:
            print(f"语音合成失败: {e}")
    
    def _play_audio(self, audio_path: str):
        """播放音频文件"""
        try:
            import pygame
            pygame.mixer.init()
            pygame.mixer.music.load(audio_path)
            pygame.mixer.music.play()
            
            # 等待播放完成
            while pygame.mixer.music.get_busy():
                time.sleep(0.1)
                
        except ImportError:
            print("需要安装 pygame: pip install pygame")
        except Exception as e:
            print(f"音频播放失败: {e}")
    
    def listen(self) -> str:
        """语音识别"""
        try:
            with self.microphone as source:
                print("请说话...")
                # 调整环境噪音
                self.recognizer.adjust_for_ambient_noise(source)
                # 监听音频
                audio = self.recognizer.listen(source, timeout=5)
                
            print("正在识别...")
            
            # 先尝试中文识别
            try:
                text = self.recognizer.recognize_google(audio, language='zh-CN')
                self.current_language = "zh"
                return text
            except:
                # 再尝试英文识别
                text = self.recognizer.recognize_google(audio, language='en-US')
                self.current_language = "en"
                return text
                
        except sr.WaitTimeoutError:
            return ""
        except sr.UnknownValueError:
            print("无法识别语音")
            return ""
        except sr.RequestError as e:
            print(f"语音识别服务错误: {e}")
            return ""
    
    def start_conversation(self):
        """开始对话循环"""
        print("语音助手已启动，说 '退出' 或 'exit' 结束对话")
        
        while True:
            # 语音识别
            user_input = self.listen()
            
            if not user_input:
                continue
                
            print(f"用户: {user_input}")
            
            # 检查退出命令
            if user_input.lower() in ['退出', 'exit', 'quit', '再见']:
                self.speak("再见！", self.current_language)
                break
            
            # 处理用户输入（这里可以集成更复杂的对话逻辑）
            response = self._process_user_input(user_input)
            
            if response:
                print(f"助手: {response}")
                self.speak(response)
    
    def _process_user_input(self, text: str) -> str:
        """处理用户输入（示例实现）"""
        text_lower = text.lower()
        
        # 简单的对话逻辑
        if any(word in text_lower for word in ['你好', 'hello', 'hi']):
            return "你好！我是你的语音助手，有什么可以帮助你的吗？"
        elif any(word in text_lower for word in ['时间', 'time']):
            from datetime import datetime
            now = datetime.now()
            return f"现在时间是 {now.strftime('%Y年%m月%d日 %H点%M分')}"
        elif any(word in text_lower for word in ['天气', 'weather']):
            return "抱歉，我还没有连接天气服务。"
        else:
            return f"你说的是：{text}。这是一个回复示例。"

# 使用示例
if __name__ == "__main__":
    # 配置多语言模型
    models_config = {
        "zh": {
            "model_dir": "checkpoints", 
            "voice": "voices/chinese_speaker.wav"
        },
        "en": {
            "model_dir": "checkpoints", 
            "voice": "voices/english_speaker.wav"
        }
    }
    
    assistant = VoiceAssistant(models_config)
    assistant.start_conversation()
```

### 3. 智能客服系统

```python
import json
import logging
from datetime import datetime
from typing import List, Dict, Optional
from dataclasses import dataclass
from indextts.infer import IndexTTS

@dataclass
class CustomerQuery:
    """客户查询数据结构"""
    id: str
    text: str
    timestamp: datetime
    language: str
    category: Optional[str] = None
    priority: str = "normal"

class IntelligentCustomerService:
    """智能客服系统"""
    
    def __init__(self, config_file: str):
        with open(config_file, 'r', encoding='utf-8') as f:
            self.config = json.load(f)
            
        # 初始化TTS
        self.tts = IndexTTS(model_dir=self.config['model_dir'])
        
        # 加载知识库
        self.knowledge_base = self._load_knowledge_base()
        
        # 加载客服语音
        self.service_voices = self.config['service_voices']
        
        # 设置日志
        self._setup_logging()
        
    def _load_knowledge_base(self) -> Dict:
        """加载知识库"""
        kb_file = self.config.get('knowledge_base_file', 'knowledge_base.json')
        try:
            with open(kb_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            self.logger.warning(f"知识库文件 {kb_file} 不存在，使用默认回复")
            return {"default": "抱歉，我需要查询相关信息后回复您。"}
    
    def _setup_logging(self):
        """设置日志系统"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('customer_service.log', encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def categorize_query(self, text: str) -> str:
        """查询分类"""
        categories = self.config.get('categories', {})
        text_lower = text.lower()
        
        for category, keywords in categories.items():
            if any(keyword in text_lower for keyword in keywords):
                return category
        
        return "general"
    
    def get_response(self, query: CustomerQuery) -> str:
        """获取回复内容"""
        category = query.category or self.categorize_query(query.text)
        
        # 从知识库获取回复
        if category in self.knowledge_base:
            responses = self.knowledge_base[category]
            if isinstance(responses, list):
                # 如果有多个回复，选择最合适的
                return self._select_best_response(query.text, responses)
            else:
                return responses
        
        # 默认回复
        return self.knowledge_base.get("default", "感谢您的咨询，我会尽快为您处理。")
    
    def _select_best_response(self, query_text: str, responses: List[str]) -> str:
        """从多个回复中选择最合适的"""
        # 简单实现：根据关键词匹配
        query_lower = query_text.lower()
        
        scored_responses = []
        for response in responses:
            score = 0
            # 计算匹配度（简化版）
            for word in query_lower.split():
                if word in response.lower():
                    score += 1
            scored_responses.append((score, response))
        
        # 返回得分最高的回复
        best_response = max(scored_responses, key=lambda x: x[0])[1]
        return best_response
    
    def generate_voice_response(
        self, 
        query: CustomerQuery, 
        response_text: str,
        voice_style: str = "friendly"
    ) -> str:
        """生成语音回复"""
        
        # 选择合适的语音
        if voice_style in self.service_voices:
            voice_file = self.service_voices[voice_style]
        else:
            voice_file = self.service_voices["default"]
        
        # 生成输出文件名
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"responses/response_{query.id}_{timestamp}.wav"
        
        # 确保输出目录存在
        os.makedirs("responses", exist_ok=True)
        
        try:
            # 生成语音
            self.tts.infer(
                audio_prompt=voice_file,
                text=response_text,
                output_path=output_file,
                temperature=0.7,  # 稍微降低随机性，保持一致性
                top_p=0.8,
                repetition_penalty=8.0
            )
            
            self.logger.info(f"为查询 {query.id} 生成语音回复: {output_file}")
            return output_file
            
        except Exception as e:
            self.logger.error(f"语音生成失败: {e}")
            raise
    
    def handle_customer_query(
        self, 
        query_text: str, 
        customer_id: str = None,
        language: str = "zh"
    ) -> Dict:
        """处理客户查询"""
        
        # 创建查询对象
        query = CustomerQuery(
            id=f"{customer_id}_{datetime.now().timestamp()}" if customer_id else str(datetime.now().timestamp()),
            text=query_text,
            timestamp=datetime.now(),
            language=language
        )
        
        # 查询分类
        query.category = self.categorize_query(query_text)
        
        # 设置优先级
        if any(urgent_word in query_text.lower() for urgent_word in ['紧急', '立即', '急', 'urgent']):
            query.priority = "high"
        
        self.logger.info(f"处理查询 {query.id}: {query.text[:50]}... (类别: {query.category})")
        
        # 获取文本回复
        response_text = self.get_response(query)
        
        # 生成语音回复
        try:
            voice_file = self.generate_voice_response(query, response_text)
            voice_generated = True
        except Exception as e:
            self.logger.error(f"语音生成失败: {e}")
            voice_file = None
            voice_generated = False
        
        # 返回结果
        result = {
            "query_id": query.id,
            "category": query.category,
            "priority": query.priority,
            "response_text": response_text,
            "voice_file": voice_file,
            "voice_generated": voice_generated,
            "timestamp": query.timestamp.isoformat()
        }
        
        # 记录处理结果
        self._log_interaction(query, result)
        
        return result
    
    def _log_interaction(self, query: CustomerQuery, result: Dict):
        """记录交互日志"""
        interaction_log = {
            "query": {
                "id": query.id,
                "text": query.text,
                "category": query.category,
                "priority": query.priority,
                "timestamp": query.timestamp.isoformat()
            },
            "response": {
                "text": result["response_text"],
                "voice_file": result["voice_file"],
                "voice_generated": result["voice_generated"]
            }
        }
        
        # 保存到日志文件
        log_file = f"logs/interactions_{datetime.now().strftime('%Y%m%d')}.jsonl"
        os.makedirs("logs", exist_ok=True)
        
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write(json.dumps(interaction_log, ensure_ascii=False) + '\n')
    
    def get_daily_statistics(self, date: str = None) -> Dict:
        """获取每日统计数据"""
        if date is None:
            date = datetime.now().strftime('%Y%m%d')
        
        log_file = f"logs/interactions_{date}.jsonl"
        
        if not os.path.exists(log_file):
            return {"error": f"No data found for date {date}"}
        
        stats = {
            "date": date,
            "total_queries": 0,
            "categories": {},
            "voice_generation_success_rate": 0,
            "high_priority_queries": 0
        }
        
        successful_voice = 0
        
        with open(log_file, 'r', encoding='utf-8') as f:
            for line in f:
                try:
                    interaction = json.loads(line.strip())
                    
                    stats["total_queries"] += 1
                    
                    # 类别统计
                    category = interaction["query"]["category"]
                    stats["categories"][category] = stats["categories"].get(category, 0) + 1
                    
                    # 优先级统计
                    if interaction["query"]["priority"] == "high":
                        stats["high_priority_queries"] += 1
                    
                    # 语音生成成功率
                    if interaction["response"]["voice_generated"]:
                        successful_voice += 1
                        
                except json.JSONDecodeError:
                    continue
        
        if stats["total_queries"] > 0:
            stats["voice_generation_success_rate"] = successful_voice / stats["total_queries"]
        
        return stats

# 配置文件示例 (config.json)
config_example = {
    "model_dir": "checkpoints",
    "service_voices": {
        "friendly": "voices/friendly_service.wav",
        "professional": "voices/professional_service.wav", 
        "default": "voices/default_service.wav"
    },
    "knowledge_base_file": "knowledge_base.json",
    "categories": {
        "product_info": ["产品", "功能", "特性", "product", "feature"],
        "technical_support": ["技术", "问题", "故障", "bug", "错误", "technical", "issue"],
        "billing": ["账单", "付款", "价格", "费用", "billing", "payment", "price"],
        "account": ["账户", "登录", "密码", "注册", "account", "login", "password"]
    }
}

# 知识库示例 (knowledge_base.json) 
knowledge_base_example = {
    "product_info": [
        "我们的产品具有以下主要功能...",
        "关于产品特性，我很乐意为您介绍...",
        "您询问的产品信息如下..."
    ],
    "technical_support": [
        "感谢您联系技术支持，请描述您遇到的具体问题...",
        "我来帮您解决技术问题...",
        "请提供更多技术细节，以便我更好地帮助您..."
    ],
    "billing": [
        "关于账单问题，我来为您查询...",
        "付款相关问题我会为您处理...",
        "费用问题请稍等，我来核实..."
    ],
    "default": "感谢您的咨询，我会尽快为您处理。请稍候..."
}

# 使用示例
if __name__ == "__main__":
    # 创建配置文件
    with open('customer_service_config.json', 'w', encoding='utf-8') as f:
        json.dump(config_example, f, ensure_ascii=False, indent=2)
    
    with open('knowledge_base.json', 'w', encoding='utf-8') as f:
        json.dump(knowledge_base_example, f, ensure_ascii=False, indent=2)
    
    # 初始化客服系统
    cs_system = IntelligentCustomerService('customer_service_config.json')
    
    # 处理客户查询
    result = cs_system.handle_customer_query(
        query_text="我想了解一下你们产品的主要功能",
        customer_id="CUST001"
    )
    
    print("处理结果:", result)
    
    # 获取统计数据
    stats = cs_system.get_daily_statistics()
    print("今日统计:", stats)
```

### 4. 个性化语音助教

```python
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from indextts.infer import IndexTTS

class PersonalizedVoiceTutor:
    """个性化语音助教系统"""
    
    def __init__(self, db_path: str = "tutor.db", model_dir: str = "checkpoints"):
        self.tts = IndexTTS(model_dir=model_dir)
        self.db_path = db_path
        self._init_database()
        
        # 不同学科的语音角色
        self.subject_voices = {
            "math": "voices/math_teacher.wav",
            "english": "voices/english_teacher.wav",
            "chinese": "voices/chinese_teacher.wav",
            "science": "voices/science_teacher.wav",
            "default": "voices/default_teacher.wav"
        }
        
    def _init_database(self):
        """初始化数据库"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # 学生表
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS students (
            id INTEGER PRIMARY KEY,
            name TEXT NOT NULL,
            grade TEXT,
            learning_style TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        ''')
        
        # 学习记录表
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS learning_records (
            id INTEGER PRIMARY KEY,
            student_id INTEGER,
            subject TEXT,
            topic TEXT,
            difficulty_level INTEGER,
            score REAL,
            time_spent INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (student_id) REFERENCES students(id)
        )
        ''')
        
        # 错题记录表
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS error_records (
            id INTEGER PRIMARY KEY,
            student_id INTEGER,
            question TEXT,
            correct_answer TEXT,
            student_answer TEXT,
            subject TEXT,
            topic TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (student_id) REFERENCES students(id)
        )
        ''')
        
        conn.commit()
        conn.close()
    
    def add_student(self, name: str, grade: str, learning_style: str = "visual") -> int:
        """添加学生"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        INSERT INTO students (name, grade, learning_style) 
        VALUES (?, ?, ?)
        ''', (name, grade, learning_style))
        
        student_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return student_id
    
    def get_student_profile(self, student_id: int) -> Optional[Dict]:
        """获取学生档案"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM students WHERE id = ?', (student_id,))
        student = cursor.fetchone()
        
        if not student:
            conn.close()
            return None
        
        # 获取学习统计
        cursor.execute('''
        SELECT subject, AVG(score) as avg_score, COUNT(*) as total_sessions
        FROM learning_records 
        WHERE student_id = ? 
        GROUP BY subject
        ''', (student_id,))
        
        subject_stats = cursor.fetchall()
        
        # 获取薄弱环节
        cursor.execute('''
        SELECT topic, COUNT(*) as error_count
        FROM error_records 
        WHERE student_id = ? 
        GROUP BY topic 
        ORDER BY error_count DESC 
        LIMIT 5
        ''', (student_id,))
        
        weak_topics = cursor.fetchall()
        
        conn.close()
        
        return {
            "id": student[0],
            "name": student[1],
            "grade": student[2],
            "learning_style": student[3],
            "created_at": student[4],
            "subject_performance": {
                subject: {"avg_score": score, "sessions": sessions} 
                for subject, score, sessions in subject_stats
            },
            "weak_topics": [{"topic": topic, "errors": count} for topic, count in weak_topics]
        }
    
    def generate_personalized_explanation(
        self, 
        student_id: int, 
        subject: str, 
        topic: str, 
        content: str,
        difficulty_level: int = 1
    ) -> str:
        """生成个性化讲解"""
        
        profile = self.get_student_profile(student_id)
        if not profile:
            raise ValueError(f"学生 {student_id} 不存在")
        
        # 根据学生特点调整讲解风格
        learning_style = profile["learning_style"]
        performance = profile["subject_performance"].get(subject, {"avg_score": 50})
        
        # 个性化前缀
        if performance["avg_score"] < 60:
            encouragement = "不要担心，我们一步步来学习。"
        elif performance["avg_score"] < 80:
            encouragement = "你做得很好，让我们继续深入学习。"
        else:
            encouragement = "你很棒！让我们挑战更有趣的内容。"
        
        # 根据学习风格调整表达方式
        if learning_style == "visual":
            style_prompt = "我用具体的例子和比喻来解释："
        elif learning_style == "auditory":
            style_prompt = "让我详细地为你讲解："
        elif learning_style == "kinesthetic":
            style_prompt = "我们通过实践的方式来理解："
        else:
            style_prompt = "让我为你解释："
        
        # 组合个性化内容
        personalized_content = f"{profile['name']}，{encouragement}{style_prompt}\n\n{content}"
        
        # 生成语音
        voice_file = self.subject_voices.get(subject, self.subject_voices["default"])
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"lessons/lesson_{student_id}_{subject}_{timestamp}.wav"
        
        # 确保输出目录存在
        os.makedirs("lessons", exist_ok=True)
        
        # 根据难度级别调整语音参数
        if difficulty_level <= 2:
            # 简单内容，语速稍慢，更清晰
            voice_params = {
                "temperature": 0.6,
                "top_p": 0.7,
                "repetition_penalty": 6.0
            }
        else:
            # 复杂内容，正常语速
            voice_params = {
                "temperature": 0.8,
                "top_p": 0.8,
                "repetition_penalty": 8.0
            }
        
        self.tts.infer(
            audio_prompt=voice_file,
            text=personalized_content,
            output_path=output_file,
            **voice_params
        )
        
        return output_file
    
    def record_learning_session(
        self, 
        student_id: int, 
        subject: str, 
        topic: str, 
        difficulty_level: int,
        score: float, 
        time_spent: int
    ):
        """记录学习会话"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        INSERT INTO learning_records 
        (student_id, subject, topic, difficulty_level, score, time_spent)
        VALUES (?, ?, ?, ?, ?, ?)
        ''', (student_id, subject, topic, difficulty_level, score, time_spent))
        
        conn.commit()
        conn.close()
    
    def record_error(
        self, 
        student_id: int, 
        question: str, 
        correct_answer: str, 
        student_answer: str, 
        subject: str, 
        topic: str
    ):
        """记录错题"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        INSERT INTO error_records 
        (student_id, question, correct_answer, student_answer, subject, topic)
        VALUES (?, ?, ?, ?, ?, ?)
        ''', (student_id, question, correct_answer, student_answer, subject, topic))
        
        conn.commit()
        conn.close()
    
    def generate_review_plan(self, student_id: int) -> Dict:
        """生成个性化复习计划"""
        profile = self.get_student_profile(student_id)
        if not profile:
            return {"error": "学生不存在"}
        
        review_plan = {
            "student_name": profile["name"],
            "generated_at": datetime.now().isoformat(),
            "recommendations": []
        }
        
        # 分析薄弱环节
        for topic_info in profile["weak_topics"][:3]:  # 取前3个薄弱环节
            topic = topic_info["topic"]
            error_count = topic_info["errors"]
            
            # 生成复习建议
            if error_count >= 5:
                priority = "高"
                suggestion = f"需要重点复习 {topic}，建议每天练习15-20分钟"
            elif error_count >= 3:
                priority = "中"
                suggestion = f"适度复习 {topic}，建议每两天练习10-15分钟"
            else:
                priority = "低"
                suggestion = f"偶尔复习 {topic}，建议每周练习一次"
            
            review_plan["recommendations"].append({
                "topic": topic,
                "priority": priority,
                "error_count": error_count,
                "suggestion": suggestion
            })
        
        return review_plan
    
    def generate_motivational_message(self, student_id: int) -> str:
        """生成激励语音消息"""
        profile = self.get_student_profile(student_id)
        if not profile:
            return ""
        
        name = profile["name"]
        
        # 获取最近的学习表现
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
        SELECT AVG(score) FROM learning_records 
        WHERE student_id = ? AND created_at >= datetime('now', '-7 days')
        ''', (student_id,))
        
        recent_avg = cursor.fetchone()[0] or 0
        conn.close()
        
        # 生成激励消息
        if recent_avg >= 80:
            message = f"{name}，你这周的表现非常棒！继续保持这种学习状态，你一定能取得更大的进步！"
        elif recent_avg >= 60:
            message = f"{name}，你的努力我都看到了！继续加油，相信你能做得更好！"
        else:
            message = f"{name}，学习需要时间和耐心。不要气馁，每一次努力都会让你更接近成功！"
        
        # 生成激励语音
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"motivation/motivation_{student_id}_{timestamp}.wav"
        
        os.makedirs("motivation", exist_ok=True)
        
        self.tts.infer(
            audio_prompt=self.subject_voices["default"],
            text=message,
            output_path=output_file,
            temperature=0.9,  # 更有表现力
            top_p=0.9
        )
        
        return output_file

# 使用示例
if __name__ == "__main__":
    tutor = PersonalizedVoiceTutor()
    
    # 添加学生
    student_id = tutor.add_student("小明", "五年级", "visual")
    
    # 记录学习会话
    tutor.record_learning_session(
        student_id=student_id,
        subject="math",
        topic="分数计算", 
        difficulty_level=2,
        score=75.0,
        time_spent=1800  # 30分钟
    )
    
    # 记录错题
    tutor.record_error(
        student_id=student_id,
        question="1/2 + 1/3 = ?",
        correct_answer="5/6",
        student_answer="2/5",
        subject="math",
        topic="分数计算"
    )
    
    # 生成个性化讲解
    audio_file = tutor.generate_personalized_explanation(
        student_id=student_id,
        subject="math",
        topic="分数计算",
        content="分数相加时，我们需要先通分。就像把不同大小的披萨片放在一起，我们需要先把它们切成同样大小的片。",
        difficulty_level=2
    )
    
    print(f"个性化讲解音频: {audio_file}")
    
    # 生成复习计划
    plan = tutor.generate_review_plan(student_id)
    print("复习计划:", json.dumps(plan, ensure_ascii=False, indent=2))
    
    # 生成激励消息
    motivation_file = tutor.generate_motivational_message(student_id)
    print(f"激励语音: {motivation_file}")
```

这些完整的应用示例展示了如何利用IndexTTS构建实用的语音应用：

1. **有声读物制作工具** - 自动将文本转换为章节化的有声读物
2. **多语言语音助手** - 支持语音识别和多语言TTS的对话系统  
3. **智能客服系统** - 基于知识库的自动客服与语音回复
4. **个性化语音助教** - 根据学生特点提供定制化的语音教学

每个示例都包含了完整的实现代码、数据库设计、配置管理和错误处理，可以直接作为产品开发的基础。 